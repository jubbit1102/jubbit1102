
# A : 정렬 대상 배열
# l, r : 정렬 범위 시작 인덱스, 종료 인덱스
def quick_sort(A, l, r):

    if l < r:
        # 기준 원소를 정해서 기준 원소의 위치를 확정
        p = partition(A, l, r)

        # 기준 원소의 왼쪽 부분 정렬
        quick_sort(A, l, p-1)

        # 기준 원소의 오른쪽 부분 정렬
        quick_sort(A, p + 1, r)


def partition(A, l, r):
    # A의 가장 왼쪽에 있는 원소가 기준
    p = A[l]

    # p보다 작은 원소를 왼쪽에
    # p보다 큰 원소를 오른쪽에

    # 앞에서부터 p보다 큰 원소를 찾고
    # 뒤에서부터 p보다 작은 원소를 찾으면
    # 이 두 원소는 위치가 잘못되어 있으니 서로 교환

    # 앞에서부터 찾기 위한 인덱스
    i = l
    # 뒤에서부터 찾기 위한 인덱스
    j = r

    # i랑 j가 교차하기 전까지 계속 반복
    while i <= j:
        # i 위치는 왼쪽에서부터 +1씩 증가
        # i번 인덱스에 있는 원소가 p보다 작으면
        # 자기 자리가 맞음, + 1 해 가며 다음 원소 탐색
        while i <= j and A[i] <= p:
            i += 1
        # j 위치는 오른쪽에서부터 -1씩 감소
        # j번 인덱스에 있는 원소가 p보다 크면
        # 자기 자리가 맞음, -1 해 가면서 다음 원소 탐색
        while i <= j and A[j] >= p:
            j -= 1

        # 두 개의 반복문이 끝나고 나서
        # 여전히 i가 j보다 작으면
        # p보다 큰 원소가 i번에 있다.
        # p보다 작은 원소가 j번에 있다.
        # 그럼 바꿔주면 된다.
        if i < j:
            A[i], A[j] = A[j], A[i]

    # i랑 j가 교차
    # 왼쪽에는 기준보다 작은 원소들이 모여있고
    # 오른쪽에는 기준보다 큰 원소들이 모여있음
    # 기준 원소를 그 사이에 끼워넣으면 위치 확정
    A[l], A[j] = A[j], A[l]
    # i와 j가 교차했으므로 j가 i보다 작은 상황
    # 기준원소(피벗)을 그중에 작은것과 바꿔야
    # 작은원소들이 왼쪽, 큰원소들이 오른쪽 이라는 규칙을
    # 지킬수 있게 된다.

    # 기준원소의 위치는 어디로 확정?? => j
    return j

T = int(input())
for tc in range(1, T + 1):
    N = int(input())
    lst = list(map(int, input().split()))

    quick_sort(lst, 0, N -1)
    print(f'#{tc} {lst[N//2]}')   # 문제에서 요구하는 N//2번 원소 출력